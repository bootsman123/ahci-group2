\documentclass[a4paper,10pt]{article}

% Language.
\usepackage[english]{babel}

% Math packages.
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}

% Smaller margins.
\usepackage[margin=0.5in]{geometry}

% Monospace font.
\usepackage{inconsolata}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Specification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Specification}
% Conceptual description of the sytem.
% For Thomas.
% With nice images ofcourse!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% System Architecture
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System Architecture}
\label{sec:system-architecture}
% Technical description of the system.
In the following section we will give an overview of the architecture of the system and the individual components.
The components are divided into three categories, namely hardware components, software components and the interaction between hardware and software components.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Hardware Components}
	% Nice image here.
		
		\subsubsection{Tabletop}
		
		\subsubsection{Beamer}
		
		\subsubsection{Webcam}


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Software Components}
	\label{sec:software-components}
	In the following section an overview is given of the individual software components, namely the \emph{game}, the \emph{server} and the \emph{Android application}.
	In section~\ref{sec:communication-protocol} an overview is given on how the server and the Android application communicate with each other.
	% Even nicer images here.

		\subsubsection{Game}
		
		
		\subsubsection{Server}
		For the server a portable version of Tomcat was used which is started at runtime every time the game starts.
		On the server we ran a single servlet which would handle all the communication between the server and the Android application.
		This setup is very flexible, since no one has to have Tomcat installed and configured on their system.
		Furthermore it allows for a tight coupling between the game and the server application.
		On the one hand a tight coupling can be seen as a disadvantage since it becomes difficult to separate the server from the game.
		On the other hand it also saves a lot of time trying to built a suitable interface between the server and the game.
				
		Since the server is tightly couple with the game it is able to access all the components of the game through the \emph{GameManager}.
		
		\subsubsection{Android Application}
		
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
	\subsection{Interaction Between Hardware and Software Components}
	% Using the title 'Interaction Between Hardware and Software Components' (or something similar) is more consistent with the rest.
	% So first you could give an overview of the different components needed for this and then how it is all tied together.

		\subsubsection{reacTIVision}
		\label{sec:reactivision}
		reactTIVision is a software component that is able to detect both finger touches on a screen and specific markers. 
		The source image (taken from the webcam under the table) is first converted to a black and white image with an adaptive thresholding algoritm. 
		This image is converted into black and white regions, which is searched for unique sequences encoded into the fiducial symbols. \cite{reactivision}.
		At every frame it detects what markers are present and sends the corresponding event as described in section \ref{sec:tuioprotocol}
		
		\subsubsection{Community Core Vision}
		\label{sec:communitycorevision}	
		Community core vision is a very advanced program that does a lot of neat image processing. 
		It detects so called "blobs" using a webcam image. 

		\subsubsection{TUIO Protocol}
		\label{sec:tuioprotocol}
		The TUIO Protocol consists of a series of event-based communication over port xxxxxxxx. 
		Everytime a message comes in a few action-based events are called.  
		As soon as a blob or a marker is detected the xxxxx function is called. 
		As soon as a marker is detected the xxxxxx function is called. 
		At every timeframe a blob or marker is updated the update() function is called with an according TUIO Point.
		Community Core Vision (CCV) is a computer vision program that takes our video input stream (taken from the webcam under the table) and outputs tracking data. \cite{ccv}.
		Several features of CCV include several filters, input and output switchers and a calibration mode. 
		Using image processing CCV checks for the blobs that represent the tops of the fingers of the user. 
		The locations and ID's of these blobs are send using the TUIO protocol described in section \ref{sec:tuioprotocol}.
		
		
		\subsubsection{TUIO Protocol}
		\label{sec:tuioprotocol}
		The TUIO Protocol consists of a series of event-based communication using OSC messages over port 3333. \cite{tuioProtocol}. 
		Using a JAVA library our program catches these messages and calls an event every time a:
		\begin{enumerate}
			\item finger is added to the screen
			\item finger is removed from the screen
			\item finger moved on the screen
			\item marker is added to the screen
			\item marker is removed from the screen
			\item marker is moved on the screen
		\end{enumerate}
		These events also include a TUIOPoint object that contains among other the:
		\begin{enumerate}
			\item Location of the finger or marker
			\item ID of the finger or marker
		\end{enumerate}
		Using these events the objects in our game are updated to their locations respective to the game on the screen as described in section \ref{waar wordts dit uitgelegd?}.
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Communication Protocol
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
\section{Communication Protocol}
\label{sec:communication-protocol}
In order for the server and the Android application to exchange information with each other we had to design a protocol.
Using certain commands the Android application is able to let the server "know" a certain action is required.

In the following sections an overview of the protocol is given.

@TODO: On every return section only the successful case is given. On an unsuccessful case \texttt{\{success:false\}} is returned.

\subsection{Connect}
Request: \texttt{?action=connect\&markId=[INTEGER]} \\
Returns: \texttt{\{success:true, phoneId:[INTEGER]\}} \\

\noindent Using the \emph{connect}-command the Android application is able to connect itself with the server.
The parameter \texttt{markId} is required and should contain the id which corresponds with the mark on the back of the phone.
If the request is successful a unique identifier \texttt{phoneId} is returned which should be used for every other request made.

\subsection{Disconnect}
Request: \texttt{?action=disconnect\&phoneId=[INTEGER]} \\
Returns: \texttt{\{success:true\}} \\

\noindent Using the \emph{disconnect}-command the Android application is able to disconnect itself with the server.
The parameter \texttt{phoneId} is required and denotes the unique identifier which is returned on a successful connect.
After a successful request any subsequent request with the given \texttt{phoneId} will fail.

\subsection{Select}
Request: \texttt{?action=select&phoneId=[INTEGER]&item=[STRING]} \\
Returns: \texttt{\{success:true\}} \\

\noindent Using the \emph{select}-command the Android application is able to select an item.
The parameter \texttt{phoneId} is required and denotes the unique identifier which is returned on a successful connect.
The parameter \textt{item} is required and denotes the item to be selected. The supported items are: \emph{whistle} and \emph{cookie}.




\bibliographystyle{apalike}
\bibliography{report}
\end{document}
